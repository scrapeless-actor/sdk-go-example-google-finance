package region

import (
	"fmt"
	"github.com/tidwall/gjson"
	"math"
	"sort"
	"strconv"
	"strings"
)

var months = []string{
	"Mar", "Jun", "Sep", "Dec",
}

type FinancialsInfo struct {
	Title  string `json:"title"`
	Result any    `json:"result"`
}

type FinancialInfo struct {
	Date             string  `json:"date"`
	Revenue          float64 `json:"revenue"`
	OperatingExpense float64 `json:"operating_expense"`
	NetIncome        float64 `json:"net_income"`
	NetProfitMargin  float64 `json:"net_profit_margin"`
	EarningsPerShare float64 `json:"earnings_per_share"`
	Ebitda           float64 `json:"ebitda"`
	EffectiveTaxRate float64 `json:"effective_tax_rate"`

	// Balance Sheet
	CashAndShortTermInvestments float64 `json:"cash_and_short_term_investments"`
	TotalAssets                 float64 `json:"total_assets"`
	TotalLiabilities            float64 `json:"total_liabilities"`
	TotalEquity                 float64 `json:"total_equity"`
	SharesOutStanding           float64 `json:"shares_out_standing"`
	PriceToBook                 float64 `json:"price_to_book"`
	ReturnOnAssets              float64 `json:"return_on_assets"`
	ReturnOnCapital             float64 `json:"return_on_capital"`

	// Cash Flow
	//NetIncome        float64 `json:"net_income"`
	CashFromOperations float64 `json:"cash_from_operations"`
	CashFromInvesting  float64 `json:"cash_from_investing"`
	CashFromFinancing  float64 `json:"cash_from_financing"`
	NetChangeInCash    float64 `json:"net_change_in_cash"`
	FreeCashFlow       float64 `json:"free_cash_flow"`
}

type FinancialsResult struct {
	Date       string `json:"date"`
	PeriodType string `json:"period_type"`
	Table      any    `json:"table"`
}

type YYChange struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Value       string `json:"value"`
	Change      string `json:"change"`
}

func GetYYChangeAll(data string) []FinancialsInfo {
	var (
		financialsResult []FinancialsInfo
	)
	quarterly, annual := financialIncomeStatementQuarterlyAndAnnual(data)
	maxQuarterlyTimes, annualTimes := getMaxTimes(quarterly, annual)
	incomeStatementQuarterlyResult := getYYChange(quarterly, maxQuarterlyTimes)          // Income Statement result
	incomeStatementAnnualResult := getYYChange(annual, annualTimes)                      // Income Statement result
	balanceSheetQuarterlyResult := getYYChangeBalanceSheet(quarterly, maxQuarterlyTimes) // Balance Sheet result
	balanceSheetAnnualResult := getYYChangeBalanceSheet(annual, annualTimes)             // Balance Sheet result
	cashFlowQuarterlyResult := getYYChangeCashFlow(quarterly, maxQuarterlyTimes)         // Cash Flow result
	cashFlowAnnualResult := getYYChangeCashFlow(annual, annualTimes)                     // Cash Flow result
	financialsResult = append(financialsResult, FinancialsInfo{
		Title:  "Income Statement result",
		Result: append(incomeStatementQuarterlyResult, incomeStatementAnnualResult...),
	}, FinancialsInfo{
		Title:  "Balance Sheet result",
		Result: append(balanceSheetQuarterlyResult, balanceSheetAnnualResult...),
	}, FinancialsInfo{
		Title:  "Cash Flow result",
		Result: append(cashFlowQuarterlyResult, cashFlowAnnualResult...),
	})
	if len(financialsResult[0].Result.([]FinancialsResult)) == 0 {
		return nil
	}
	return financialsResult
}
func getYYChange(data map[string]FinancialInfo, need []string) []FinancialsResult {
	var (
		financialsResult []FinancialsResult
		dataType         = "Quarterly"
	)
	for _, s := range need {
		var resp []YYChange
		dateMonth := ""
		dataArray := strings.Split(s, "-")
		if len(dataArray) > 1 {
			atoi, _ := strconv.Atoi(dataArray[1])
			dateMonth = months[atoi-1]
		}
		if dateMonth != "" {
			dateMonth = dateMonth + " " + dataArray[0]
		} else {
			dateMonth = dataArray[0]
		}
		now := data[s]
		old := FinancialInfo{}
		if strings.Contains(s, "-") {
			split := strings.Split(s, "-")
			year, _ := strconv.ParseInt(split[0], 10, 64)
			quarter, _ := strconv.ParseInt(split[1], 10, 64)
			tmpK := fmt.Sprintf("%d-%d", year-1, quarter)
			old = data[tmpK]
		} else {
			dataType = "Annual"
			year, _ := strconv.ParseInt(s, 10, 64)
			tmpK := fmt.Sprintf("%d", year-1)
			old = data[tmpK]
		}
		resp = append(resp, YYChange{
			Title:       "Revenue",
			Description: "The total amount of income generated by the sale of goods or services related to the company's primary operations",
			Value:       strconv.FormatFloat(now.Revenue, 'f', -1, 64),
			Change:      fmt.Sprintf("%.2f%%", (now.Revenue-old.Revenue)/old.Revenue*float64(100)),
		}, YYChange{
			Title:       "Operating expense",
			Description: "Represents the total incurred expenses through normal operations",
			Value:       strconv.FormatFloat(now.OperatingExpense, 'f', -1, 64),
			Change:      fmt.Sprintf("%.2f%%", (now.OperatingExpense-old.OperatingExpense)/old.OperatingExpense*float64(100)),
		},
			YYChange{
				Title:       "Net income",
				Description: "Company’s earnings for a period net of operating costs, taxes, and interest",
				Value:       strconv.FormatFloat(now.NetIncome, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.NetIncome-old.NetIncome)/old.NetIncome*float64(100)),
			},
			YYChange{
				Title:       "Net profit margin",
				Description: "Measures how much net income or profit is generated as a percentage of revenue.",
				Value:       strconv.FormatFloat(now.NetProfitMargin, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.NetProfitMargin-old.NetProfitMargin)/old.NetProfitMargin*float64(100)),
			},
			YYChange{
				Title:       "Earnings per share",
				Description: "Represents the company's profit divided by the outstanding shares of its common stock.",
				Value:       strconv.FormatFloat(now.EarningsPerShare, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.EarningsPerShare-old.EarningsPerShare)/old.EarningsPerShare*float64(100)),
			},
			YYChange{
				Title:       "EBITDA",
				Description: "Earnings before interest, taxes, depreciation, and amortization, is a measure of a company's overall financial performance and is used as an alternative to net income in some circumstances",
				Value:       strconv.FormatFloat(now.Ebitda, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.Ebitda-old.Ebitda)/old.Ebitda*float64(100)),
			},
			YYChange{
				Title:       "Effective tax rate",
				Description: "Measures how much net income or profit is generated as a percentage of revenue.",
				Value:       fmt.Sprintf("%s%%", strconv.FormatFloat(now.EffectiveTaxRate, 'f', -1, 64)),
				Change:      "-",
			},
		)
		financialsResult = append(financialsResult, FinancialsResult{
			Date:       dateMonth,
			PeriodType: dataType,
			Table:      resp,
		})
	}
	return financialsResult
}

func getYYChangeBalanceSheet(data map[string]FinancialInfo, need []string) []FinancialsResult {
	var (
		financialsResult []FinancialsResult
		dataType         = "Quarterly"
	)
	for _, s := range need {
		var resp []YYChange
		dateMonth := ""
		dataArray := strings.Split(s, "-")
		if len(dataArray) > 1 {
			atoi, _ := strconv.Atoi(dataArray[1])
			dateMonth = months[atoi-1]
		}
		if dateMonth != "" {
			dateMonth = dateMonth + " " + dataArray[0]
		} else {
			dateMonth = dataArray[0]
		}
		now := data[s]
		old := FinancialInfo{}
		if strings.Contains(s, "-") {
			split := strings.Split(s, "-")
			year, _ := strconv.ParseInt(split[0], 10, 64)
			quarter, _ := strconv.ParseInt(split[1], 10, 64)
			tmpK := fmt.Sprintf("%d-%d", year-1, quarter)
			old = data[tmpK]
		} else {
			dataType = "Annual"
			// 按年的
			year, _ := strconv.ParseInt(s, 10, 64)
			tmpK := fmt.Sprintf("%d", year-1)
			old = data[tmpK]
		}
		resp = append(resp, YYChange{
			Title:       "Cash and short-term investments",
			Description: "Investments that are relatively liquid and have maturities between 3 months and one year",
			Value:       strconv.FormatFloat(now.CashAndShortTermInvestments, 'f', -1, 64),
			Change:      fmt.Sprintf("%.2f%%", (now.CashAndShortTermInvestments-old.CashAndShortTermInvestments)/old.CashAndShortTermInvestments*float64(100)),
		}, YYChange{
			Title:       "Total assets",
			Description: "The total amount of assets owned by a company",
			Value:       strconv.FormatFloat(now.TotalAssets, 'f', -1, 64),
			Change:      fmt.Sprintf("%.2f%%", (now.TotalAssets-old.TotalAssets)/old.TotalAssets*float64(100)),
		},
			YYChange{
				Title:       "Total liabilities",
				Description: "Sum of the combined debts a company owes",
				Value:       strconv.FormatFloat(now.TotalLiabilities, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.TotalLiabilities-old.TotalLiabilities)/old.TotalLiabilities*float64(100)),
			},
			YYChange{
				Title:       "Total equity",
				Description: "The value of subtracting the total liabilities from the total assets of a company",
				Value:       strconv.FormatFloat(now.TotalEquity, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.TotalEquity-old.TotalEquity)/old.TotalEquity*float64(100)),
			},
			YYChange{
				Title:       "Shares outstanding",
				Description: "Total number of common shares outstanding as of the latest date disclosed in a financial filing",
				Value:       strconv.FormatFloat(now.SharesOutStanding, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.SharesOutStanding-old.SharesOutStanding)/old.SharesOutStanding*float64(100)),
			},
			YYChange{
				Title:       "Price to book",
				Description: "A ratio used to determine if a company’s market value is in line with the value of its assets less liabilities and preferred stock",
				Value:       strconv.FormatFloat(now.PriceToBook, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.PriceToBook-old.PriceToBook)/old.PriceToBook*float64(100)),
			},
			YYChange{
				Title:       "Return on assets",
				Description: "A financial ratio that shows a company’s profitability compared to its assets",
				Value:       fmt.Sprintf("%s%%", strconv.FormatFloat(now.ReturnOnAssets, 'f', -1, 64)),
				Change:      "-",
			},
			YYChange{
				Title:       "Return on capital",
				Description: "Company’s return above the average cost it pays for its debt and equity capital",
				Value:       fmt.Sprintf("%s%%", strconv.FormatFloat(now.ReturnOnCapital, 'f', -1, 64)),
				Change:      "-",
			},
		)
		financialsResult = append(financialsResult, FinancialsResult{
			Date:       dateMonth,
			PeriodType: dataType,
			Table:      resp,
		})
	}
	return financialsResult
}

func getYYChangeCashFlow(data map[string]FinancialInfo, need []string) []FinancialsResult {
	var (
		financialsResult []FinancialsResult
		dataType         = "Quarterly"
	)
	for _, s := range need {
		var resp []YYChange
		dateMonth := ""
		dataArray := strings.Split(s, "-")
		if len(dataArray) > 1 {
			atoi, _ := strconv.Atoi(dataArray[1])
			dateMonth = months[atoi-1]
		}
		if dateMonth != "" {
			dateMonth = dateMonth + " " + dataArray[0]
		} else {
			dateMonth = dataArray[0]
		}
		now := data[s]
		old := FinancialInfo{}
		if strings.Contains(s, "-") {
			split := strings.Split(s, "-")
			year, _ := strconv.ParseInt(split[0], 10, 64)
			quarter, _ := strconv.ParseInt(split[1], 10, 64)
			tmpK := fmt.Sprintf("%d-%d", year-1, quarter)
			old = data[tmpK]
		} else {
			dataType = "Annual"
			// 按年的
			year, _ := strconv.ParseInt(s, 10, 64)
			tmpK := fmt.Sprintf("%d", year-1)
			old = data[tmpK]
		}
		resp = append(resp, YYChange{
			Title:       "Net income",
			Description: "Company’s earnings for a period net of operating costs, taxes, and interest",
			Value:       strconv.FormatFloat(now.NetIncome, 'f', -1, 64),
			Change:      fmt.Sprintf("%.2f%%", (now.NetIncome-old.NetIncome)/old.NetIncome*float64(100)),
		}, YYChange{
			Title:       "Cash from operations",
			Description: "Net cash used or generated for core business activities",
			Value:       strconv.FormatFloat(now.CashFromOperations, 'f', -1, 64),
			Change:      fmt.Sprintf("%.2f%%", (now.CashFromOperations-old.CashFromOperations)/old.CashFromOperations*float64(100)),
		},
			YYChange{
				Title:       "Cash from investing",
				Description: "Net cash used or generated in investing activities such as purchasing assets",
				Value:       strconv.FormatFloat(now.CashFromInvesting, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.CashFromInvesting-old.CashFromInvesting)/math.Abs(old.CashFromInvesting)*float64(100)),
			},
			YYChange{
				Title:       "Cash from financing",
				Description: "Net cash used or generated in financing activities such as dividend payments and loans",
				Value:       strconv.FormatFloat(now.CashFromFinancing, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.CashFromFinancing-old.CashFromFinancing)/math.Abs(old.CashFromFinancing)*float64(100)),
			},
			YYChange{
				Title:       "Net change in cash",
				Description: "The amount by which a company's cash balance increases or decreases in an accounting period",
				Value:       strconv.FormatFloat(now.NetChangeInCash, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.NetChangeInCash-old.NetChangeInCash)/math.Abs(old.NetChangeInCash)*float64(100)),
			},
			YYChange{
				Title:       "Free cash flow",
				Description: "Amount of cash a business has after it has met its financial obligations such as debt and outstanding payments",
				Value:       strconv.FormatFloat(now.FreeCashFlow, 'f', -1, 64),
				Change:      fmt.Sprintf("%.2f%%", (now.FreeCashFlow-old.FreeCashFlow)/old.FreeCashFlow*float64(100)),
			},
		)
		financialsResult = append(financialsResult, FinancialsResult{
			Date:       dateMonth,
			PeriodType: dataType,
			Table:      resp,
		})
	}
	return financialsResult
}

func financialIncomeStatementQuarterlyAndAnnual(data string) (map[string]FinancialInfo, map[string]FinancialInfo) {
	var (
		quarterly = make(map[string]FinancialInfo)
		annual    = make(map[string]FinancialInfo)
	)
	for _, v := range gjson.Parse(data).Get("0.0.0").Array() {
		year := v.Get("0").Int()
		quarter := v.Get("1").Int()
		k := fmt.Sprintf("%d-%d", year, quarter)
		if k == "0-0" {
			continue
		}
		revenue := v.Get("2.0").Float()
		operatingExpense := v.Get("2.38").Float()
		netIncome := v.Get("2.1").Float()
		netProfitMargin := v.Get("2.3").Float()
		earningsPerShare := v.Get("2.2").Float()
		ebitda := v.Get("2.20").Float()
		effectiveTaxRate := v.Get("2.21").Float()

		// Balance Sheet
		cashAndShortTermInvestments := v.Get("2.22").Float()
		totalAssets := v.Get("2.23").Float()
		TotalEquity := v.Get("2.25").Float()
		TotalLiabilities := v.Get("2.26").Float()
		sharesOutStanding := v.Get("2.27").Float()
		returnOnAssets := v.Get("2.34").Float()
		priceToBook := v.Get("2.35").Float()
		returnOnCapital := v.Get("2.18").Float()

		// Cash Flow
		cashFromOperations := v.Get("2.28").Float()
		cashFromInvesting := v.Get("2.29").Float()
		cashFromFinancing := v.Get("2.30").Float()
		freeCashFlow := v.Get("2.31").Float()
		netChangeInCash := v.Get("2.5").Float()

		quarterly[k] = FinancialInfo{
			Date:             k,
			Revenue:          revenue,
			OperatingExpense: operatingExpense,
			NetIncome:        netIncome,
			NetProfitMargin:  netProfitMargin,
			EarningsPerShare: earningsPerShare,
			Ebitda:           ebitda,
			EffectiveTaxRate: effectiveTaxRate,

			CashAndShortTermInvestments: cashAndShortTermInvestments,
			TotalAssets:                 totalAssets,
			TotalLiabilities:            TotalLiabilities,
			TotalEquity:                 TotalEquity,
			SharesOutStanding:           sharesOutStanding,
			PriceToBook:                 priceToBook,
			ReturnOnAssets:              returnOnAssets,
			ReturnOnCapital:             returnOnCapital,

			CashFromOperations: cashFromOperations,
			CashFromInvesting:  cashFromInvesting,
			CashFromFinancing:  cashFromFinancing,
			NetChangeInCash:    netChangeInCash,
			FreeCashFlow:       freeCashFlow,
		}
	}
	for _, v := range gjson.Parse(data).Get("0.0.1").Array() {
		year := v.Get("0").Int()
		k := fmt.Sprintf("%d", year)
		revenue := v.Get("1.0").Float()
		operatingExpense := v.Get("1.38").Float()
		netIncome := v.Get("1.1").Float()
		netProfitMargin := v.Get("1.3").Float()
		earningsPerShare := v.Get("1.2").Float()
		ebitda := v.Get("1.20").Float()
		effectiveTaxRate := v.Get("1.21").Float()

		// Balance Sheet
		cashAndShortTermInvestments := v.Get("1.22").Float()
		totalAssets := v.Get("1.23").Float()
		TotalEquity := v.Get("1.25").Float()
		TotalLiabilities := v.Get("1.26").Float()
		sharesOutStanding := v.Get("1.27").Float()
		returnOnAssets := v.Get("1.34").Float()
		priceToBook := v.Get("1.35").Float()
		returnOnCapital := v.Get("1.18").Float()

		// Cash Flow
		cashFromOperations := v.Get("1.28").Float()
		cashFromInvesting := v.Get("1.29").Float()
		cashFromFinancing := v.Get("1.30").Float()
		freeCashFlow := v.Get("1.31").Float()
		netChangeInCash := v.Get("1.5").Float()
		annual[k] = FinancialInfo{
			Date:             k,
			Revenue:          revenue,
			OperatingExpense: operatingExpense,
			NetIncome:        netIncome,
			NetProfitMargin:  netProfitMargin,
			EarningsPerShare: earningsPerShare,
			Ebitda:           ebitda,
			EffectiveTaxRate: effectiveTaxRate,

			CashAndShortTermInvestments: cashAndShortTermInvestments,
			TotalAssets:                 totalAssets,
			TotalLiabilities:            TotalLiabilities,
			TotalEquity:                 TotalEquity,
			SharesOutStanding:           sharesOutStanding,
			PriceToBook:                 priceToBook,
			ReturnOnAssets:              returnOnAssets,
			ReturnOnCapital:             returnOnCapital,

			CashFromOperations: cashFromOperations,
			CashFromInvesting:  cashFromInvesting,
			CashFromFinancing:  cashFromFinancing,
			NetChangeInCash:    netChangeInCash,
			FreeCashFlow:       freeCashFlow,
		}
	}
	return quarterly, annual
}

func getMaxTimes(quarterly map[string]FinancialInfo, annual map[string]FinancialInfo) ([]string, []string) {
	var (
		quarterlyKey = make([]string, len(quarterly))
		annualKey    = make([]string, len(quarterly))
	)
	for k, _ := range quarterly {
		quarterlyKey = append(quarterlyKey, k)
	}
	sort.Slice(quarterlyKey, func(i, j int) bool {
		return quarterlyKey[i] > quarterlyKey[j]
	})
	for k, _ := range annual {
		annualKey = append(annualKey, k)
	}
	sort.Slice(annualKey, func(i, j int) bool {
		return annualKey[i] > annualKey[j]
	})
	if len(quarterlyKey) > 5 {
		quarterlyKey = quarterlyKey[:5]
	}
	if len(annualKey) > 5 {
		annualKey = annualKey[:5]
	}
	return quarterlyKey, annualKey
}
